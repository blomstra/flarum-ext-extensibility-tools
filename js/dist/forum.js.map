{"version":3,"file":"forum.js","mappings":"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","sources":["webpack://@blomstra/extensibility-tools/./node_modules/css-what/lib/es/types.js","webpack://@blomstra/extensibility-tools/./node_modules/css-what/lib/es/parse.js","webpack://@blomstra/extensibility-tools/./src/common/utils/findAndModVdomChild.ts","webpack://@blomstra/extensibility-tools/webpack/bootstrap","webpack://@blomstra/extensibility-tools/webpack/runtime/compat get default export","webpack://@blomstra/extensibility-tools/webpack/runtime/define property getters","webpack://@blomstra/extensibility-tools/webpack/runtime/hasOwnProperty shorthand","webpack://@blomstra/extensibility-tools/webpack/runtime/make namespace object"],"sourcesContent":["export var SelectorType;\n(function (SelectorType) {\n    SelectorType[\"Attribute\"] = \"attribute\";\n    SelectorType[\"Pseudo\"] = \"pseudo\";\n    SelectorType[\"PseudoElement\"] = \"pseudo-element\";\n    SelectorType[\"Tag\"] = \"tag\";\n    SelectorType[\"Universal\"] = \"universal\";\n    // Traversals\n    SelectorType[\"Adjacent\"] = \"adjacent\";\n    SelectorType[\"Child\"] = \"child\";\n    SelectorType[\"Descendant\"] = \"descendant\";\n    SelectorType[\"Parent\"] = \"parent\";\n    SelectorType[\"Sibling\"] = \"sibling\";\n    SelectorType[\"ColumnCombinator\"] = \"column-combinator\";\n})(SelectorType || (SelectorType = {}));\n/**\n * Modes for ignore case.\n *\n * This could be updated to an enum, and the object is\n * the current stand-in that will allow code to be updated\n * without big changes.\n */\nexport const IgnoreCaseMode = {\n    Unknown: null,\n    QuirksMode: \"quirks\",\n    IgnoreCase: true,\n    CaseSensitive: false,\n};\nexport var AttributeAction;\n(function (AttributeAction) {\n    AttributeAction[\"Any\"] = \"any\";\n    AttributeAction[\"Element\"] = \"element\";\n    AttributeAction[\"End\"] = \"end\";\n    AttributeAction[\"Equals\"] = \"equals\";\n    AttributeAction[\"Exists\"] = \"exists\";\n    AttributeAction[\"Hyphen\"] = \"hyphen\";\n    AttributeAction[\"Not\"] = \"not\";\n    AttributeAction[\"Start\"] = \"start\";\n})(AttributeAction || (AttributeAction = {}));\n","import { SelectorType, AttributeAction, } from \"./types\";\nconst reName = /^[^\\\\#]?(?:\\\\(?:[\\da-f]{1,6}\\s?|.)|[\\w\\-\\u00b0-\\uFFFF])+/;\nconst reEscape = /\\\\([\\da-f]{1,6}\\s?|(\\s)|.)/gi;\nconst actionTypes = new Map([\n    [126 /* Tilde */, AttributeAction.Element],\n    [94 /* Circumflex */, AttributeAction.Start],\n    [36 /* Dollar */, AttributeAction.End],\n    [42 /* Asterisk */, AttributeAction.Any],\n    [33 /* ExclamationMark */, AttributeAction.Not],\n    [124 /* Pipe */, AttributeAction.Hyphen],\n]);\n// Pseudos, whose data property is parsed as well.\nconst unpackPseudos = new Set([\n    \"has\",\n    \"not\",\n    \"matches\",\n    \"is\",\n    \"where\",\n    \"host\",\n    \"host-context\",\n]);\n/**\n * Checks whether a specific selector is a traversal.\n * This is useful eg. in swapping the order of elements that\n * are not traversals.\n *\n * @param selector Selector to check.\n */\nexport function isTraversal(selector) {\n    switch (selector.type) {\n        case SelectorType.Adjacent:\n        case SelectorType.Child:\n        case SelectorType.Descendant:\n        case SelectorType.Parent:\n        case SelectorType.Sibling:\n        case SelectorType.ColumnCombinator:\n            return true;\n        default:\n            return false;\n    }\n}\nconst stripQuotesFromPseudos = new Set([\"contains\", \"icontains\"]);\n// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152\nfunction funescape(_, escaped, escapedWhitespace) {\n    const high = parseInt(escaped, 16) - 0x10000;\n    // NaN means non-codepoint\n    return high !== high || escapedWhitespace\n        ? escaped\n        : high < 0\n            ? // BMP codepoint\n                String.fromCharCode(high + 0x10000)\n            : // Supplemental Plane codepoint (surrogate pair)\n                String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);\n}\nfunction unescapeCSS(str) {\n    return str.replace(reEscape, funescape);\n}\nfunction isQuote(c) {\n    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;\n}\nfunction isWhitespace(c) {\n    return (c === 32 /* Space */ ||\n        c === 9 /* Tab */ ||\n        c === 10 /* NewLine */ ||\n        c === 12 /* FormFeed */ ||\n        c === 13 /* CarriageReturn */);\n}\n/**\n * Parses `selector`, optionally with the passed `options`.\n *\n * @param selector Selector to parse.\n * @param options Options for parsing.\n * @returns Returns a two-dimensional array.\n * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),\n * the second contains the relevant tokens for that selector.\n */\nexport function parse(selector) {\n    const subselects = [];\n    const endIndex = parseSelector(subselects, `${selector}`, 0);\n    if (endIndex < selector.length) {\n        throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);\n    }\n    return subselects;\n}\nfunction parseSelector(subselects, selector, selectorIndex) {\n    let tokens = [];\n    function getName(offset) {\n        const match = selector.slice(selectorIndex + offset).match(reName);\n        if (!match) {\n            throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);\n        }\n        const [name] = match;\n        selectorIndex += offset + name.length;\n        return unescapeCSS(name);\n    }\n    function stripWhitespace(offset) {\n        selectorIndex += offset;\n        while (selectorIndex < selector.length &&\n            isWhitespace(selector.charCodeAt(selectorIndex))) {\n            selectorIndex++;\n        }\n    }\n    function readValueWithParenthesis() {\n        selectorIndex += 1;\n        const start = selectorIndex;\n        let counter = 1;\n        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {\n            if (selector.charCodeAt(selectorIndex) ===\n                40 /* LeftParenthesis */ &&\n                !isEscaped(selectorIndex)) {\n                counter++;\n            }\n            else if (selector.charCodeAt(selectorIndex) ===\n                41 /* RightParenthesis */ &&\n                !isEscaped(selectorIndex)) {\n                counter--;\n            }\n        }\n        if (counter) {\n            throw new Error(\"Parenthesis not matched\");\n        }\n        return unescapeCSS(selector.slice(start, selectorIndex - 1));\n    }\n    function isEscaped(pos) {\n        let slashCount = 0;\n        while (selector.charCodeAt(--pos) === 92 /* BackSlash */)\n            slashCount++;\n        return (slashCount & 1) === 1;\n    }\n    function ensureNotTraversal() {\n        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {\n            throw new Error(\"Did not expect successive traversals.\");\n        }\n    }\n    function addTraversal(type) {\n        if (tokens.length > 0 &&\n            tokens[tokens.length - 1].type === SelectorType.Descendant) {\n            tokens[tokens.length - 1].type = type;\n            return;\n        }\n        ensureNotTraversal();\n        tokens.push({ type });\n    }\n    function addSpecialAttribute(name, action) {\n        tokens.push({\n            type: SelectorType.Attribute,\n            name,\n            action,\n            value: getName(1),\n            namespace: null,\n            ignoreCase: \"quirks\",\n        });\n    }\n    /**\n     * We have finished parsing the current part of the selector.\n     *\n     * Remove descendant tokens at the end if they exist,\n     * and return the last index, so that parsing can be\n     * picked up from here.\n     */\n    function finalizeSubselector() {\n        if (tokens.length &&\n            tokens[tokens.length - 1].type === SelectorType.Descendant) {\n            tokens.pop();\n        }\n        if (tokens.length === 0) {\n            throw new Error(\"Empty sub-selector\");\n        }\n        subselects.push(tokens);\n    }\n    stripWhitespace(0);\n    if (selector.length === selectorIndex) {\n        return selectorIndex;\n    }\n    loop: while (selectorIndex < selector.length) {\n        const firstChar = selector.charCodeAt(selectorIndex);\n        switch (firstChar) {\n            // Whitespace\n            case 32 /* Space */:\n            case 9 /* Tab */:\n            case 10 /* NewLine */:\n            case 12 /* FormFeed */:\n            case 13 /* CarriageReturn */: {\n                if (tokens.length === 0 ||\n                    tokens[0].type !== SelectorType.Descendant) {\n                    ensureNotTraversal();\n                    tokens.push({ type: SelectorType.Descendant });\n                }\n                stripWhitespace(1);\n                break;\n            }\n            // Traversals\n            case 62 /* GreaterThan */: {\n                addTraversal(SelectorType.Child);\n                stripWhitespace(1);\n                break;\n            }\n            case 60 /* LessThan */: {\n                addTraversal(SelectorType.Parent);\n                stripWhitespace(1);\n                break;\n            }\n            case 126 /* Tilde */: {\n                addTraversal(SelectorType.Sibling);\n                stripWhitespace(1);\n                break;\n            }\n            case 43 /* Plus */: {\n                addTraversal(SelectorType.Adjacent);\n                stripWhitespace(1);\n                break;\n            }\n            // Special attribute selectors: .class, #id\n            case 46 /* Period */: {\n                addSpecialAttribute(\"class\", AttributeAction.Element);\n                break;\n            }\n            case 35 /* Hash */: {\n                addSpecialAttribute(\"id\", AttributeAction.Equals);\n                break;\n            }\n            case 91 /* LeftSquareBracket */: {\n                stripWhitespace(1);\n                // Determine attribute name and namespace\n                let name;\n                let namespace = null;\n                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */) {\n                    // Equivalent to no namespace\n                    name = getName(1);\n                }\n                else if (selector.startsWith(\"*|\", selectorIndex)) {\n                    namespace = \"*\";\n                    name = getName(2);\n                }\n                else {\n                    name = getName(0);\n                    if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&\n                        selector.charCodeAt(selectorIndex + 1) !==\n                            61 /* Equal */) {\n                        namespace = name;\n                        name = getName(1);\n                    }\n                }\n                stripWhitespace(0);\n                // Determine comparison operation\n                let action = AttributeAction.Exists;\n                const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));\n                if (possibleAction) {\n                    action = possibleAction;\n                    if (selector.charCodeAt(selectorIndex + 1) !==\n                        61 /* Equal */) {\n                        throw new Error(\"Expected `=`\");\n                    }\n                    stripWhitespace(2);\n                }\n                else if (selector.charCodeAt(selectorIndex) === 61 /* Equal */) {\n                    action = AttributeAction.Equals;\n                    stripWhitespace(1);\n                }\n                // Determine value\n                let value = \"\";\n                let ignoreCase = null;\n                if (action !== \"exists\") {\n                    if (isQuote(selector.charCodeAt(selectorIndex))) {\n                        const quote = selector.charCodeAt(selectorIndex);\n                        let sectionEnd = selectorIndex + 1;\n                        while (sectionEnd < selector.length &&\n                            (selector.charCodeAt(sectionEnd) !== quote ||\n                                isEscaped(sectionEnd))) {\n                            sectionEnd += 1;\n                        }\n                        if (selector.charCodeAt(sectionEnd) !== quote) {\n                            throw new Error(\"Attribute value didn't end\");\n                        }\n                        value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));\n                        selectorIndex = sectionEnd + 1;\n                    }\n                    else {\n                        const valueStart = selectorIndex;\n                        while (selectorIndex < selector.length &&\n                            ((!isWhitespace(selector.charCodeAt(selectorIndex)) &&\n                                selector.charCodeAt(selectorIndex) !==\n                                    93 /* RightSquareBracket */) ||\n                                isEscaped(selectorIndex))) {\n                            selectorIndex += 1;\n                        }\n                        value = unescapeCSS(selector.slice(valueStart, selectorIndex));\n                    }\n                    stripWhitespace(0);\n                    // See if we have a force ignore flag\n                    const forceIgnore = selector.charCodeAt(selectorIndex) | 0x20;\n                    // If the forceIgnore flag is set (either `i` or `s`), use that value\n                    if (forceIgnore === 115 /* LowerS */) {\n                        ignoreCase = false;\n                        stripWhitespace(1);\n                    }\n                    else if (forceIgnore === 105 /* LowerI */) {\n                        ignoreCase = true;\n                        stripWhitespace(1);\n                    }\n                }\n                if (selector.charCodeAt(selectorIndex) !==\n                    93 /* RightSquareBracket */) {\n                    throw new Error(\"Attribute selector didn't terminate\");\n                }\n                selectorIndex += 1;\n                const attributeSelector = {\n                    type: SelectorType.Attribute,\n                    name,\n                    action,\n                    value,\n                    namespace,\n                    ignoreCase,\n                };\n                tokens.push(attributeSelector);\n                break;\n            }\n            case 58 /* Colon */: {\n                if (selector.charCodeAt(selectorIndex + 1) === 58 /* Colon */) {\n                    tokens.push({\n                        type: SelectorType.PseudoElement,\n                        name: getName(2).toLowerCase(),\n                        data: selector.charCodeAt(selectorIndex) ===\n                            40 /* LeftParenthesis */\n                            ? readValueWithParenthesis()\n                            : null,\n                    });\n                    continue;\n                }\n                const name = getName(1).toLowerCase();\n                let data = null;\n                if (selector.charCodeAt(selectorIndex) ===\n                    40 /* LeftParenthesis */) {\n                    if (unpackPseudos.has(name)) {\n                        if (isQuote(selector.charCodeAt(selectorIndex + 1))) {\n                            throw new Error(`Pseudo-selector ${name} cannot be quoted`);\n                        }\n                        data = [];\n                        selectorIndex = parseSelector(data, selector, selectorIndex + 1);\n                        if (selector.charCodeAt(selectorIndex) !==\n                            41 /* RightParenthesis */) {\n                            throw new Error(`Missing closing parenthesis in :${name} (${selector})`);\n                        }\n                        selectorIndex += 1;\n                    }\n                    else {\n                        data = readValueWithParenthesis();\n                        if (stripQuotesFromPseudos.has(name)) {\n                            const quot = data.charCodeAt(0);\n                            if (quot === data.charCodeAt(data.length - 1) &&\n                                isQuote(quot)) {\n                                data = data.slice(1, -1);\n                            }\n                        }\n                        data = unescapeCSS(data);\n                    }\n                }\n                tokens.push({ type: SelectorType.Pseudo, name, data });\n                break;\n            }\n            case 44 /* Comma */: {\n                finalizeSubselector();\n                tokens = [];\n                stripWhitespace(1);\n                break;\n            }\n            default: {\n                if (selector.startsWith(\"/*\", selectorIndex)) {\n                    const endIndex = selector.indexOf(\"*/\", selectorIndex + 2);\n                    if (endIndex < 0) {\n                        throw new Error(\"Comment was not terminated\");\n                    }\n                    selectorIndex = endIndex + 2;\n                    // Remove leading whitespace\n                    if (tokens.length === 0) {\n                        stripWhitespace(0);\n                    }\n                    break;\n                }\n                let namespace = null;\n                let name;\n                if (firstChar === 42 /* Asterisk */) {\n                    selectorIndex += 1;\n                    name = \"*\";\n                }\n                else if (firstChar === 124 /* Pipe */) {\n                    name = \"\";\n                    if (selector.charCodeAt(selectorIndex + 1) === 124 /* Pipe */) {\n                        addTraversal(SelectorType.ColumnCombinator);\n                        stripWhitespace(2);\n                        break;\n                    }\n                }\n                else if (reName.test(selector.slice(selectorIndex))) {\n                    name = getName(0);\n                }\n                else {\n                    break loop;\n                }\n                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&\n                    selector.charCodeAt(selectorIndex + 1) !== 124 /* Pipe */) {\n                    namespace = name;\n                    if (selector.charCodeAt(selectorIndex + 1) ===\n                        42 /* Asterisk */) {\n                        name = \"*\";\n                        selectorIndex += 2;\n                    }\n                    else {\n                        name = getName(1);\n                    }\n                }\n                tokens.push(name === \"*\"\n                    ? { type: SelectorType.Universal, namespace }\n                    : { type: SelectorType.Tag, name, namespace });\n            }\n        }\n    }\n    finalizeSubselector();\n    return selectorIndex;\n}\n","import { parse as cssWhat, Selector } from 'css-what';\nimport type Mithril from 'mithril';\n\ntype VdomChildren = Mithril.Vnode<Record<string, unknown>> | Mithril.Vnode<Record<string, unknown>>[];\n\ntype ManipulationFunction = (vnode: Mithril.Vnode<Record<string, unknown>>) => void;\n\n/**\n * Removes the first child in a tree of VDOM nodes which matches the given selector.\n *\n * @param vdom a VDOM tree\n * @param selector CSS selector of the child to remove\n * @returns `true` a child was found and removed, otherwise `false`\n */\nexport function findAndRemoveFirstVdomChild(vdom: VdomChildren, selector: string): boolean {\n  const node = findFirstVdomChild(vdom, selector);\n\n  if (node === undefined) return false;\n\n  // Set to empty fragment\n  node.tag = '[';\n  node.attrs = { removedViaVdomUtils: true };\n  node.children = [];\n\n  return true;\n}\n\n/**\n * Finds the first child in a tree of VDOM nodes which matches the given selector.\n *\n * This node can then be manipulated, if desired, with the `manipulationFunc` param.\n *\n * @example\n * <caption>Adding a new child to a discussion list item title</caption>\n *\n * ```\n * extend(DiscussionListItem.prototype, 'view', function (vnode) {\n *   findFirstVdomChild(vnode, '.DiscussionListItem-title', (vnode) => {\n *     const children = [];\n *\n *     // Ensure the node is an array of children\n *     if (vnode.text) {\n *       children.push({ tag: '#', children: `${vnode.text}` } as Mithril.Vnode);\n *       delete vnode.text;\n *     }\n *\n *     if (Array.isArray(vnode.children)) {\n *       children.push(...vnode.children);\n *     }\n *\n *     // Add our own custom child\n *     children.push(<span>!!!</span>);\n *\n *     // Assign the new array of children to the node\n *     vnode.children = children;\n *   });\n * });\n * ```\n *\n * @param vdom a VDOM tree\n * @param selector CSS selector of the child to find or manipulate\n * @param manipulationFunc\n * @returns The child that was found, or `undefined` if no child was found\n */\nexport function findFirstVdomChild(\n  vdom: VdomChildren,\n  selector: string,\n  manipulationFunc?: ManipulationFunction\n): Mithril.Vnode<Record<string, unknown>> | undefined {\n  const parsedSelector = cssWhat(selector);\n\n  return searchChildren(vdom, parsedSelector, manipulationFunc);\n}\n\nfunction searchChildren(\n  vdom: (Mithril.Child | Mithril.Children)[] | (Mithril.Child | Mithril.Children),\n  selectors: Selector[][],\n  manipulationFunc?: ManipulationFunction\n): Mithril.Vnode<Record<string, unknown>> | undefined {\n  let nodes: (Mithril.Child | Mithril.Children)[];\n\n  if (!Array.isArray(vdom)) {\n    nodes = [vdom];\n  } else {\n    nodes = vdom;\n  }\n\n  let found: Mithril.Vnode<Record<string, unknown>, {}> | undefined = undefined;\n\n  nodes.some((node): boolean => {\n    if (typeof node === 'boolean' || typeof node === 'number' || typeof node === 'string' || node === null || node === undefined) return false;\n\n    if (Array.isArray(node)) {\n      let result = searchChildren(node, selectors, manipulationFunc);\n\n      if (result) {\n        found = result;\n        return true;\n      }\n\n      return false;\n    }\n\n    if (doesChildMatchSelectors(node, selectors)) {\n      found = node;\n      return true;\n    }\n\n    if (Array.isArray(node.children)) {\n      let result = searchChildren(node.children, selectors);\n\n      if (result) {\n        found = result;\n        return true;\n      }\n\n      return false;\n    }\n\n    return false;\n  });\n\n  if (manipulationFunc && found) manipulationFunc(found);\n\n  return found;\n}\n\nfunction doesChildMatchSelectors(child: Mithril.Vnode<Record<string, any>>, selectors: Selector[][]): boolean {\n  return selectors.some((selector) => {\n    return selector.every((criterion): boolean => {\n      switch (criterion.type) {\n        case 'tag':\n          return child.tag === criterion.name;\n\n        case 'attribute':\n          if (!child.attrs) return false;\n\n          if (criterion.name === 'class') criterion.name = 'className';\n\n          let attr = child.attrs[criterion.name];\n\n          if (criterion.name === 'className' && typeof attr === 'string') {\n            attr = attr.trim();\n          }\n\n          if (criterion.ignoreCase && typeof attr === 'string') {\n            attr = attr.toLowerCase();\n            criterion.value = criterion.value.toLowerCase();\n          }\n\n          switch (criterion.action) {\n            case 'exists':\n              return child.attrs.hasOwnProperty(criterion.name);\n            case 'equals':\n              return attr === criterion.value;\n            case 'start':\n              return attr?.startsWith?.(criterion.value) || false;\n            case 'end':\n              return attr?.endsWith?.(criterion.value) || false;\n            case 'element':\n              return (attr as string)?.split?.(' ')?.includes?.(criterion.value) || false;\n          }\n      }\n\n      return false;\n    });\n  });\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"names":["SelectorType","AttributeAction","reName","reEscape","actionTypes","Map","Element","Start","End","Any","Not","Hyphen","unpackPseudos","Set","stripQuotesFromPseudos","funescape","_","escaped","escapedWhitespace","high","parseInt","String","fromCharCode","unescapeCSS","str","replace","isQuote","c","isWhitespace","parse","selector","subselects","endIndex","parseSelector","length","Error","slice","selectorIndex","tokens","getName","offset","match","name","stripWhitespace","charCodeAt","readValueWithParenthesis","start","counter","isEscaped","pos","slashCount","ensureNotTraversal","type","Adjacent","Child","Descendant","Parent","Sibling","ColumnCombinator","isTraversal","addTraversal","push","addSpecialAttribute","action","Attribute","value","namespace","ignoreCase","finalizeSubselector","pop","loop","firstChar","Equals","startsWith","Exists","possibleAction","get","quote","sectionEnd","valueStart","forceIgnore","attributeSelector","PseudoElement","toLowerCase","data","has","quot","Pseudo","indexOf","test","Universal","Tag","findAndRemoveFirstVdomChild","vdom","node","findFirstVdomChild","undefined","tag","attrs","removedViaVdomUtils","children","manipulationFunc","searchChildren","cssWhat","selectors","nodes","Array","isArray","found","some","result","child","every","criterion","attr","trim","hasOwnProperty","endsWith","split","includes","doesChildMatchSelectors","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","obj","prop","prototype","call","r","Symbol","toStringTag"],"sourceRoot":""}